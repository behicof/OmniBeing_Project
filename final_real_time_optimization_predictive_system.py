from sklearn.ensemble import VotingClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.tree import DecisionTreeClassifier
import requests

class FinalRealTimeOptimizationPredictiveSystem:
    def __init__(self):
        """
        Initializes the ensemble predictive system with six machine learning classifiers and sets up internal data storage.
        
        Combines RandomForest, LogisticRegression, SVC, GradientBoosting, AdaBoost, and DecisionTree classifiers into a hard voting ensemble. Initializes lists for storing market data features, labels, predictions, live data entries, and a variable for model accuracy.
        """
        self.rf_model = RandomForestClassifier(n_estimators=500)
        self.lr_model = LogisticRegression(max_iter=10000)
        self.svm_model = SVC(kernel='poly')
        self.gb_model = GradientBoostingClassifier(n_estimators=400)
        self.ada_model = AdaBoostClassifier(n_estimators=250)
        self.dt_model = DecisionTreeClassifier(max_depth=15)
        
        self.voting_classifier = VotingClassifier(estimators=[
            ('rf', self.rf_model),
            ('lr', self.lr_model),
            ('svm', self.svm_model),
            ('gb', self.gb_model),
            ('ada', self.ada_model),
            ('dt', self.dt_model)
        ], voting='hard')
        
        self.market_data = []
        self.labels = []
        self.multi_stage_predictions = []
        self.model_accuracy = 0
        self.live_data = []

    def receive_live_data(self, platform_name, data):
        # دریافت داده‌های زنده از پلتفرم‌های مختلف
        """
        Store live market data from a specified platform in the internal live data list.
        
        Parameters:
            platform_name: The name of the platform providing the market data.
            data: The live market data to be stored.
        """
        self.live_data.append({"platform": platform_name, "data": data})

    def process_market_data(self, market_data):
        # پردازش داده‌های بازار برای تحلیل و پیش‌بینی
        """
        Extracts sentiment, volatility, and price change features from market data, stores them for model training, and returns the feature list.
        
        Parameters:
        	market_data (dict): Market data containing 'sentiment', 'volatility', 'price_change', and 'buy_sell_signal' keys.
        
        Returns:
        	list: Extracted feature values as [sentiment, volatility, price_change].
        """
        features = [market_data['sentiment'], market_data['volatility'], market_data['price_change']]
        self.market_data.append(features)
        self.labels.append(market_data['buy_sell_signal'])
        return features

    def train_models(self):
        # آموزش مدل‌ها با داده‌های بازار
        """
        Train the ensemble voting classifier using all stored market data and labels.
        
        Fits the voting classifier on the accumulated feature vectors and their corresponding labels if any training data is available.
        """
        if len(self.market_data) > 0:
            X = np.array(self.market_data)
            y = np.array(self.labels)
            self.voting_classifier.fit(X, y)
    
    def make_predictions(self, market_data):
        # پیش‌بینی با مدل‌های ترکیبی
        features = [market_data['sentiment'], market_data['volatility'], market_data['price_change']]
        prediction = self.voting_classifier.predict([features])
        combined_prediction = "hold"
        
        if prediction == 1:
            combined_prediction = "buy"
        elif prediction == 0:
            combined_prediction = "sell"
        
        self.multi_stage_predictions.append(combined_prediction)
        return combined_prediction
    
    def evaluate_model_accuracy(self):
        # ارزیابی دقت مدل‌ها
        """
        Calculate and return the accuracy of the ensemble voting classifier on all accumulated market data and labels.
        
        Returns:
            float: Accuracy score of the model on the stored dataset.
        """
        X = np.array(self.market_data)
        y = np.array(self.labels)
        predictions = self.voting_classifier.predict(X)
        
        self.model_accuracy = accuracy_score(y, predictions)
        return self.model_accuracy
    
    def get_predictions(self):
        """
        Return all predictions generated by the ensemble model up to the current point.
        
        Returns:
            list: A list of prediction strings ("buy", "sell", or "hold") made so far.
        """
        return self.multi_stage_predictions

    def fetch_live_data(self, platform_name, url):
        """
        Fetches live market data from the specified URL, associates it with the given platform name, stores it internally, and returns the parsed data.
        
        Parameters:
            platform_name (str): The name of the platform from which the data is sourced.
            url (str): The URL endpoint to retrieve live market data.
        
        Returns:
            dict: The JSON-parsed market data retrieved from the URL.
        """
        response = requests.get(url)
        data = response.json()
        self.receive_live_data(platform_name, data)
        return data

    def process_live_data(self):
        """
        Processes all stored live market data entries and generates predictions for each using the ensemble model.
        
        Iterates through the internal live data list, extracting features from each entry and producing predictions based on the ensemble classifier.
        """
        for entry in self.live_data:
            platform_name = entry['platform']
            data = entry['data']
            self.process_market_data(data)
            self.make_predictions(data)
